import "reflect-metadata";
import { CONTROLLERS_REGISTRY, ParamType } from "../common/types";
import { logger } from "../common/logger";

/**
 * Represents a single route definition within a controller.
 * Contains HTTP method, path, handler, and parameter metadata.
 */
export interface RouteDefinition {
  /** HTTP method (GET, POST, etc.) */
  method: string;
  /** Route path relative to controller base path */
  path: string;
  /** Full computed path (basePath + path) */
  fullPath: string;
  /** Name of the controller method handling this route */
  handlerName: string;
  /** Route order for conflict resolution (higher = higher priority) */
  order: number;
  /** Parameter injection metadata (@Body, @Param, etc.) */
  paramsMeta: any[];
}

/**
 * Complete metadata for a controller including all its routes.
 * Generated by MetadataScanner from decorator information.
 */
export interface ControllerMetadata {
  /** Controller instance */
  instance: any;
  /** Base path for all routes in this controller */
  basePath: string;
  /** All route definitions in this controller */
  routes: RouteDefinition[];
}

/**
 * Scans all registered controllers and extracts routing metadata.
 * Uses reflect-metadata to read decorator information and build routing table.
 */
export class MetadataScanner {
  /**
   * Scan all registered controllers and build route metadata.
   * Instantiates controllers, sorts routes by order, and computes full paths.
   *
   * @returns Array of controller metadata with route definitions
   * @throws Error if no controllers are registered
   */
  static scan(): ControllerMetadata[] {
    if (CONTROLLERS_REGISTRY.length === 0) {
      logger.minimal(
        "âŒ No controllers found. Did you forget @Controller() decorator?",
      );
      throw new Error(
        "No controllers registered. Add @Controller() to at least one class.",
      );
    }

    return CONTROLLERS_REGISTRY.map((ControllerClass) => {
      // Instantiate controller
      const instance = new ControllerClass();
      const basePath = Reflect.getMetadata("basePath", ControllerClass) || "/";
      let routes = Reflect.getMetadata("routes", ControllerClass) || [];

      // Sort routes by order (higher = higher priority for overlapping routes)
      routes = routes.sort((a: any, b: any) => a.order - b.order);

      // Log controller info
      logger.info(`ðŸŽ® \x1b[1m${ControllerClass.name}\x1b[0m`);

      // Process each route
      const processedRoutes = routes.map((route: any) => {
        // Compute full path: basePath + route.path (normalized)
        const fullPath =
          (basePath + route.path).replace("//", "/").replace(/\/$/, "") || "/";

        // Get parameter injection metadata
        const paramsMeta =
          Reflect.getMetadata("route_params", instance, route.handlerName) ||
          [];

        // Log route with decorators and order
        const argsLog =
          paramsMeta.length > 0
            ? paramsMeta.map((p: any) => `\x1b[90m@${p.type}\x1b[0m`).join(", ")
            : "\x1b[90m(Auto-Merge)\x1b[0m";
        const orderLog =
          route.order > 0 ? `\x1b[35m[Order:${route.order}]\x1b[0m` : "";
        logger.debug(
          `    â”œâ”€â”€ ${route.method}\t${fullPath} \t${argsLog} ${orderLog}`,
        );

        return { ...route, fullPath, paramsMeta };
      });
      logger.info("");

      return { instance, basePath, routes: processedRoutes };
    });
  }
}
